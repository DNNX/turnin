module Service.AsciiArt
( toAsciiArt
) where

import qualified Data.Map as M
import Data.Maybe
import Data.Char

ls = M.fromList
 [ ('0',
    [ "   @@@  "
    , "  @   @ "
    , " @     @"
    , " @     @"
    , " @     @"
    , "  @   @ "
    , "   @@@  "
    ]), ('1',
    [ "    @   "
    , "   @@   "
    , "  @ @   "
    , "    @   "
    , "    @   "
    , "    @   "
    , "  @@@@@ "
    ]), ('2',
    [ "  @@@@@ "
    , " @     @"
    , "       @"
    , "  @@@@@ "
    , " @      "
    , " @      "
    , " @@@@@@@"
    ]), ('3',
    [ "  @@@@@ "
    , " @     @"
    , "       @"
    , "  @@@@@ "
    , "       @"
    , " @     @"
    , "  @@@@@ "
    ]), ('4',
    [ " @      "
    , " @    @ "
    , " @    @ "
    , " @    @ "
    , " @@@@@@@"
    , "      @ "
    , "      @ "
    ]), ('5',
    [ " @@@@@@@"
    , " @      "
    , " @      "
    , " @@@@@@ "
    , "       @"
    , " @     @"
    , "  @@@@@ "
    ]), ('6',
    [ "  @@@@@ "
    , " @     @"
    , " @      "
    , " @@@@@@ "
    , " @     @"
    , " @     @"
    , "  @@@@@ "
    ]), ('7',
    [ " @@@@@@@"
    , " @    @ "
    , "     @  "
    , "    @   "
    , "   @    "
    , "   @    "
    , "   @    "
    ]), ('8',
    [ "  @@@@@ "
    , " @     @"
    , " @     @"
    , "  @@@@@ "
    , " @     @"
    , " @     @"
    , "  @@@@@ "
    ]), ('9',
    [ "  @@@@@ "
    , " @     @"
    , " @     @"
    , "  @@@@@@"
    , "       @"
    , " @     @"
    , "  @@@@@ "
    ]), ('a',
    [ "    @   "
    , "   @ @  "
    , "  @   @ "
    , " @     @"
    , " @@@@@@@"
    , " @     @"
    , " @     @"
    ]), ('b',
    [ " @@@@@@ "
    , " @     @"
    , " @     @"
    , " @@@@@@ "
    , " @     @"
    , " @     @"
    , " @@@@@@ "
    ]), ('c',
    [ "  @@@@@ "
    , " @     @"
    , " @      "
    , " @      "
    , " @      "
    , " @     @"
    , "  @@@@@ "
    ]), ('d',
    [ " @@@@@@ "
    , " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , " @@@@@@ "
    ]), ('e',
    [ " @@@@@@@"
    , " @      "
    , " @      "
    , " @@@@@  "
    , " @      "
    , " @      "
    , " @@@@@@@"
    ]), ('f',
    [ " @@@@@@@"
    , " @      "
    , " @      "
    , " @@@@@  "
    , " @      "
    , " @      "
    , " @      "
    ]), ('g',
    [ "  @@@@@ "
    , " @     @"
    , " @      "
    , " @  @@@@"
    , " @     @"
    , " @     @"
    , "  @@@@@ "
    ]), ('h',
    [ " @     @"
    , " @     @"
    , " @     @"
    , " @@@@@@@"
    , " @     @"
    , " @     @"
    , " @     @"
    ]), ('i',
    [ "   @@@  "
    , "    @   "
    , "    @   "
    , "    @   "
    , "    @   "
    , "    @   "
    , "   @@@  "
    ]), ('j',
    [ "       @"
    , "       @"
    , "       @"
    , "       @"
    , " @     @"
    , " @     @"
    , "  @@@@@ "
    ]), ('k',
    [ " @    @ "
    , " @   @  "
    , " @  @   "
    , " @@@    "
    , " @  @   "
    , " @   @  "
    , " @    @ "
    ]), ('l',
    [ " @      "
    , " @      "
    , " @      "
    , " @      "
    , " @      "
    , " @      "
    , " @@@@@@@"
    ]), ('m',
    [ " @     @"
    , " @@   @@"
    , " @ @ @ @"
    , " @  @  @"
    , " @     @"
    , " @     @"
    , " @     @"
    ]), ('n',
    [ " @     @"
    , " @@    @"
    , " @ @   @"
    , " @  @  @"
    , " @   @ @"
    , " @    @@"
    , " @     @"
    ]), ('o',
    [ " @@@@@@@"
    , " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , " @@@@@@@"
    ]), ('p',
    [ " @@@@@@ "
    , " @     @"
    , " @     @"
    , " @@@@@@ "
    , " @      "
    , " @      "
    , " @      "
    ]), ('q',
    [ "  @@@@@ "
    , " @     @"
    , " @     @"
    , " @     @"
    , " @   @ @"
    , " @    @ "
    , "  @@@@ @"
    ]), ('r',
    [ " @@@@@@ "
    , " @     @"
    , " @     @"
    , " @@@@@@ "
    , " @   @  "
    , " @    @ "
    , " @     @"
    ]), ('s',
    [ "  @@@@@ "
    , " @     @"
    , " @      "
    , "  @@@@@ "
    , "       @"
    , " @     @"
    , "  @@@@@ "
    ]), ('t',
    [ " @@@@@@@"
    , "    @   "
    , "    @   "
    , "    @   "
    , "    @   "
    , "    @   "
    , "    @   "
    ]), ('u',
    [ " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , "  @@@@@ "
    ]), ('v',
    [ " @     @"
    , " @     @"
    , " @     @"
    , " @     @"
    , "  @   @ "
    , "   @ @  "
    , "    @   "
    ]), ('w',
    [ " @     @"
    , " @  @  @"
    , " @  @  @"
    , " @  @  @"
    , " @  @  @"
    , " @  @  @"
    , "  @@ @@ "
    ]), ('x',
    [ " @     @"
    , "  @   @ "
    , "   @ @  "
    , "    @   "
    , "   @ @  "
    , "  @   @ "
    , " @     @"
    ]), ('y',
    [ " @     @"
    , "  @   @ "
    , "   @ @  "
    , "    @   "
    , "    @   "
    , "    @   "
    , "    @   "
    ]), ('z',
    [ " @@@@@@@"
    , "      @ "
    , "     @  "
    , "    @   "
    , "   @    "
    , "  @     "
    , " @@@@@@@"
    ]), ('_',
    [ "        "
    , "        "
    , "        "
    , "        "
    , "        "
    , "        "
    , " @@@@@@@"
    ])
 ]

notFound =
    [ " x . . ."
    , " . . . ."
    , " . . . ."
    , " . . . ."
    , " . . . ."
    , " . . . ."
    , " . . . ."
    ]

toAsciiArt :: String -> String
toAsciiArt s = let bigLetters = map toBigLetter s
               in  unlines $ foldl concatElems (replicate height []) bigLetters

-- private utils
height = length $ fromJust $ M.lookup '0' ls
width = length $ head $ fromJust $ M.lookup '0' ls

letters = let ls' = M.toList ls
              allHaveSameHeight = all (\(_,xs) -> length xs == height) ls'
              allHaveSameWidth  = all (\(_,xs) -> all ((==width).length) xs) ls'
          in  if allHaveSameHeight && allHaveSameWidth then ls else error "Letters aren't of same height or width"

toBigLetter c = let result = M.lookup (toLower c) letters
                in  fromMaybe notFound result

concatElems []     []     = []
concatElems (x:xs) (y:ys) = (x++y):concatElems xs ys
concatElems _      _      = error "Lists should have same length"


